---
title: "Data Quality Visualizations"
author: "Zack Arno"
date: '2022-11-15'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro



```{r libs_data}
library(tidyverse)
library(here)

invisible(purrr::map(dir(here("R/"),full.names = T),~source(.x,verbose = FALSE,echo = F)))
targets::tar_load_everything()
```


Good no cases where pop treated during current month is > total population
```{r}
pop_treated_gt_total_pop<- RB_pre_post_compiled |>
  filter(
    popn_treated_during_current_month>total_population
  )
```

We see there are now **`r nrow(pop_treated_gt_total_pop)`** cases where the reported # treated monthly is greater than the total population reported that month.

Let's visually inspect adm2 level monthly reported pop treated vs total population. 

- There are some high outliers? anything to do about these?
- Generally looks pretty decent

```{r}
rb_boxplot(.data = RB_pre_post_compiled,
           x = "adm2_name",
           y = "popn_treated_during_current_month",
           pop = "total_population" )


# log scaled
rb_boxplot(.data = RB_pre_post_compiled,
           x = "adm2_name",
           y = "popn_treated_during_current_month",
           pop = "total_population" ,log = T)



```

I think we should inspect the pop treated over time to make sure the numbers looks good. Alright, I like that, doesn't look lik numbers are getting repeated.

```{r}
RB_pre_post_compiled |>
  ggplot(aes(x=date,y=popn_treated_during_current_month,color=adm2_name))+
  geom_point()+
  geom_line()+
  scale_y_continuous(labels = scales::comma)+
  scale_x_date(date_breaks = "6 month",date_labels = "%Y-%b",date_minor_breaks = "1 month")+
  theme_bw()+
  labs(y="Population Treated")+
  theme(
    axis.text.x = element_text(angle=90)
  )

```
Let's lookat at `adm3` level post 201905

- hmm that doesn't look too good ... what's going on?
```{r}

RB_post201905_adm3 |> 
  ggplot(
    aes(x= date,
        y=popn_treated_during_current_month,
        color=adm3_name,
        group=adm3_name,
        )
  )+
  geom_path()+
  theme(
    legend.position = "none"
  )

```

```{r}
na_pop_treated_adm3 <- RB_post201905_adm3 |>
  filter(is.na(popn_treated_during_current_month))
```

For `popn_treated_during_current_month`, only **`r nrow(RB_post201905_adm3)`** out of **`nrow(na_pop_treated_adm3)`** values not recorded as `NA`... let's replace those NAs with `0` 

boom, viz makes more sense. Chosen to show each admin 3 as a a line, but color by adm 2 group. Can play with this.
```{r}


RB_post201905_adm3 |> 
  mutate(
  popn_treated_during_current_month=  replace_na(popn_treated_during_current_month,replace = 0)
  ) |> 
    ggplot(
    aes(x= date,
        y=popn_treated_during_current_month,
        color=adm2_name,
        group=adm3_name,
        )
  )+
  geom_path()+
  geom_point()+
  scale_y_continuous(labels = scales::comma)+
  scale_x_date(date_breaks = "1 month",date_labels = "%Y-%b")+
  labs(y="Pop Treated Current Month")+
  theme_bw()+
  theme(
    axis.text.x = element_text(angle=90),
    legend.position = "none"

  )
  
```



Shold fin out a bit more about cumulative all_rounds
```{r}
RB_adm2 |> 
  filter(
    popn_treated_cumulative_all_rounds>total_population
  )

RB_adm2$popn_treated_cumulative_all_rounds
rb_boxplot(.data = RB_adm2,
           x = "adm2_name",
           y = "popn_treated_cumulative_all_rounds",
           pop = "total_population" )
```


Now let's do the same just at the woreda (adm3/district level). We only have woreda level reporting for post 2019-05 data.
```{r}
pop_treated_gt_total_pop_adm3<- RB_post201905_df_compiled |> 
  filter(
    popn_treated_during_current_month>total_population
  )

pop_treated_gt_total_pop_adm3 |> count(date, adm3_name)
```
We see there are now **`r nrow(pop_treated_gt_total_pop_adm3)`** cases where the reported # treated monthly is greater than the total population reported that month.

```{r}
rb_boxplot(.data = RB_post201905_df_compiled,
           x = "adm3_name",
           y = "popn_treated_during_current_month",
           facet = "adm1_name",
           pop = "total_population" )


 # log scaled
rb_boxplot(.data = RB_adm2,
           x = "adm2_name",
           y = "popn_treated_during_current_month",
           pop = "total_population" ,log = T)

```

## Carry over

We know that sometimes there are cases where pop treated numbers in J-F-M appear to be carried over from previous year. It's unclear exactly how this is happening. We think that the December ones might be getting back filled? Here is a Viz where you can clearly see it occuring at the admin 2 level. 


```{r}
ggiraph::girafe()
ggiraph::girafe(ggobj = heat_map_gg(RB_pre_post_compiled))
```

It appears to be occuring both in pre 2019-05 and post 2019-05 data. Therefore to identify the problematic entries we should look at both pre & post data sets (adm 2 & 3 levels). Lets' start with adm2

I guess we should first Isolate the months of interest

```{r}####```{r}
```{r}
```{r}
#############################3
# this is useful       

#################################3
# this is useful
##################################
RB_pre_post_compiled |> 
    arrange(date) |>
    group_by(year,
             adm1_name,
             adm2_name
    ) |>
    summarise(
      treated_cumulative = cumsum(popn_treated_during_current_month),
      utg_total = utg_2_treatment_target_for_the_whole_year,
      date= unique(date),.groups = "keep"
    ) |> 
  summarise(
    mincum=min(treated_cumulative),
    maxcum=max(treated_cumulative),
    pct= mincum/maxcum
  ) |> 
  filter(mincum>0) |> 
  filter(pct>.75) |> 
  print(n=21)



max_cur_minus_min_pre <-  function(df,
                                   group_level=c("adm1_name","adm2_name")){
  years_unique <- c(2017:2022)
  group_level_sym <-  syms(group_level)
  years_unique |> 
    purrr::map_dfr(
      ~{
        prev_nov_dec <- df |> 
          filter(year==.x-1) |> 
          group_by(!!!group_level_sym) |> 
          summarise(
            treated_cumulative = cumsum(popn_treated_during_current_month),
            date= date
            # date= lubridate::ymd(unique(date)),
            # .groups = "keep"
          ) |> 
          summarise(
            date= lubridate::ymd(unique(date)),.groups = "keep",
            cum_compare=max(treated_cumulative,na.rm=T),
            # pct= mincum/maxcum
          ) |> 
          filter(lubridate::month(date) %in% c(11,12))
        
        curr_janfebmar <- df |> 
          filter(year==.x) |> 
          group_by(!!!group_level_sym) |> 
          mutate(
            treated_cumulative = cumsum(popn_treated_during_current_month),
            date= date
            # date= lubridate::ymd(unique(date)),
            # .groups = "keep"
          ) |> 
          summarise(
            date= lubridate::ymd(unique(date)),.groups = "keep",
            cum_compare=min(treated_cumulative,na.rm=T)
            
          ) |> 
             filter(lubridate::month(date) %in% c(1,2))
        
        df_consec_months<-bind_rows(prev_nov_dec,curr_janfebmar)
        df_consec_months |> 
          group_by(!!!group_level_sym) |> 
          summarise(
            date= unique(date),
            min_cum = min(cum_compare,na.rm=T),
            year= lubridate::year(date),
            diff_range= diff(range(cum_compare)),
            date_set= .x
            )
      }
      
    )
}




year_comparisons<- max_cur_minus_min_pre(RB_pre_post_compiled)
year_comparisons_adm3<- max_cur_minus_min_pre(RB_post201905_adm3,
                                         group_level = c("adm1_name","adm2_name","adm3_name"))

year_comparisons |>
  filter(min_cum!=0) |> 
  ggplot(aes(x=diff_range))+
  geom_histogram(bins = 100)+
  facet_wrap(~date_set)+
  scale_x_log10(label=scales::comma)
year_comparisons_adm3 |>
  filter(min_cum!=0) |> 
  ggplot(aes(x=diff_range))+
  geom_histogram(bins = 100)+
  facet_wrap(~date_set)+
  scale_x_log10(label=scales::comma)

year_comparisons |>
  filter(min_cum!=0) |> 
  filter(diff_range<5000) |> 
  rename(start_of_year=date_set) |> 
  distinct(adm1_name,adm2_name,diff_range,start_of_year ) |> 
  filter(!is.na(adm1_name)) |> 
  arrange(adm1_name,adm2_name,start_of_year) |> 
  select(-diff_range)

year_comparisons_adm3 |>
  filter(min_cum!=0) |> 
  filter(diff_range<5000) |> 
  rename(start_of_year=date_set) |> 
  distinct(adm1_name,adm2_name,diff_range,start_of_year ) |> 
  filter(!is.na(adm1_name)) |> 
  arrange(adm1_name,adm2_name,start_of_year) |> 
  select(-diff_range)

targets::tar_load_everything(
  
)

#          
#        
#         mutate(
#           treated_cumulative= sum(popn_treated_during_current_month),
#         ) |> 
#         group_by(adm1_name, adm2_name) |> 
#         summarise(
#           year= unique(year),
#           year_prev= unique(year)-1,
#           min_cum = min(treated_cumulative,na.rm=T),
#           max_cum= max(treated_cumulative,na.rm=T)
#         )
#     ) |> 
#     rlang::set_names(years_unique)
# }
max_cur_minus_min_pre(RB_pre_post_compiled)$`2021` |> print(n=30)


RB_pre_post_compiled |> 
  
  filter(
    !(date %in% lubridate::ymd(c("2016-01-01",
                                 "2016-02-01",
                                 "2016-03-01",
                                 "2016-04-01")))
  )   |>
  mutate(prev_year= year -1) |> 
  arrange(date) |>
  
    group_by(year,
             adm1_name,
             adm2_name
    ) |>
    mutate(
      treated_cumulative = cumsum(popn_treated_during_current_month),
      max_cum = max(treated_cumulative,na.rm=T),
      min_cum = min(treated_cumulative,na.rm=T)
      # utg_total = utg_2_treatment_target_for_the_whole_year,
      # date= unique(date),.groups = "keep"
    ) 


RB_pre_post_compiled |> 
  # group_by(year,
  #          adm1_name,
  #          adm2_name
  # ) |>
  filter(
    !(date %in% lubridate::ymd(c("2016-01-01",
                                 "2016-02-01",
                                 "2016-03-01",
                                 "2016-04-01")))
  ) |>
  mutate(
    month_rev = ifelse(month == 12 ,1,month),
    year_rev= ifelse(month==12, year+1,year)
  ) |> 
  group_by(year_rev,adm1_name,adm2_name) |> 
  summarise(
    diff_range = diff(range(popn_treated_during_current_month))
  ) |> 
  filter(diff_range< 10000) |> 
  print(n=33)
  
  group_by(adm1_name,adm2_name) |>
  mutate(
    cum_lag = unique(max_treated_cum[year==year-1])
  )
  
  select(matches("*cum*")) |> filter(adm2_name =="yem_special", year ==2018) |> glimpse()
  filter(
    date<="2019-05-01",
    # issue can't apply to first year
    !(date %in% lubridate::ymd(c("2016-01-01",
                  "2016-02-01",
                  "2016-03-01",
                  "2016-04-01"))),
    # month %in% c(12,1,2)
  ) |> 
  group_by(year) |> 
  mutate(
    
  )
  filter(adm2_name=="central_gondar")
  mutate(
    month=ifelse(month==12,0,month)
  ) |> 
  group_by(adm1_name,adm2_name,popn_treated_during_current_month) |>
  count() |> 
  filter(popn_treated_during_current_month!=0)
  print(n=62)
  filter(month == 12 | month == 01 | month == 02) %>%
    filter(year[month == 12] == year[month == 01] - 1 &
             year[month == 12] == year[month == 02] - 1)

  # mutate(
  #   res= seqid(12*as.yearmon(date))
  # )


lubridate::month()
DF %>% 
  group_by(group, result = seqid(12 * as.yearmon(date))) %>%
  mutate(result = 1:n()) %>%
  ungroup
```




```{r}
  dat_p <- .dat |>
    arrange(date) |>
    group_by(year,
             adm1_name,
             adm2_name
    ) |>
    summarise(
      treated_cumulative = cumsum(popn_treated_during_current_month),
      utg_total = utg_2_treatment_target_for_the_whole_year,
      date= unique(date),.groups = "keep"
    ) |>
    mutate(
      updated_utg_total = utg_total[which(date==max(date))],
      pct_treated_utg_total = treated_cumulative/updated_utg_total,
      year = lubridate::year(date),
      month= lubridate::month(date)
    ) |>
    filter(!is.na(adm2_name))
```

